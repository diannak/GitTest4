클래스 안쪽에 만들어지는 네스티드 클래스를 가르켜서 인더 클래스라고 함. 또 세개로 갈라짐.
위를 만들고 위를 통해서만 접근할 수 있음.
static안붙은것 인너 클래스

static은 얘네끼리 공유해서 쓸수 잇음. 별도의 객체가 아니다. 
private는 접근 못하지만 static은 접근할 수 있다.

B1--
외부의 클래스가 필요함 
멤버 클래스 Member를 쓰기위해서는 / 같은 영역내에 있기 때문에.

이 외부 클래스가 혹은 그 안에 있는 멤버 클래스가 private이면 못찾아들어감. 

B2 --관리하기 편해서 사용

다른 작업에 쓸때는 외부 클래스 

B4-
프린트 기능 하나필요한데도 선언다해줘야함
기능만 잠시 만들어 쓰여질 아이라 이름을 굳이 지어주지않음.
1:1 매칭만 잘 시키면 됨.
객체지향적인 언어라 객체 하나를 사용하는데에도 일일이 만들어줘야함.

C1
람다식 =  함수형 프로그램.
객체를 안만들고 함수형을 만드려고 하니 약간의 조작을 하게됨. 
함수의 호출만으로 기능을 수행.
조금 줄여쓰겠다는 의지.

파라미터만 주고 원하는 함수만 뽑아내면 됨. 찍는 기능만을 하겠따. 
interface 프린트 기능을 하겠다 선언해준것. 

D--
메소드가 2개일 경우에
함수형 인터페이스 = 펑셔널인터페이스 어노테이션을 달아놓으면 에러가 남.

비교기능만 있으면 되는데 쓸데없이 껍데기의 객체를 하나를 더 만들어야함. 
-> 이래서 람다가 필요하다.

ch22
보조스트림 = 기능을 조금씩 추가해주는것.
output stream 원형 
자식을 부모에~형변화 해당.
out close꼭 해줘야지 안그러면 락걸려서 안지워지고 메모리 잡아먹어

finally 를 붙여서 안전하게 닫기 설정해놓음.

in.read (buf) 버퍼만큼 읽고 씀

flush 더이상 필요없어.
writer에는 한글 쓰기 쉽다.
String은 흐름을 그냥 갖다 던진다.

문자 단위 Reader writer
동영상 등등은 inputStream outputSream

직렬화: 줄세워서 쓰겠댱 == Serializable
암호화된것에는 사용하면 안됌.

24---스레드: 실행 흐름을 이루는 최소단위 
프로세스: 메모리에 떠있음 여러단위로 나뉨. 실행이 되는 작은 단위= 스레드
Tread ct = 관찰자 
스레드 실행하기 위해선 = run이 필요. run 추상메서드 반드시 필요.	
start 실행시작. 할일이 끝나면 죽으나 아니면 별도의 프로그램으로 계속 살아있음 (독립된 실행객체)
main thread 실행시켜놓고 다른일 하다가 thread가 끝나면 비로소 main도 종료됨.
아무래도 main 보다는 동작이 많아서 느리고 결과가 뒤에 찍힘.
Thread sleep 스레드 몇초간 쉬어-> 이때문에 더 있다가 결과가 뜸.
절차 지향적.
객체 지향적 : 

메인 - static 수집 - 
join 스레드의 종료를 기다림.
스레드의 속도가 똑같이 도는게 아님. 각각 상이한 속도로 진행됨.
동일 메모리내에서 값을 공유할때 동시에 값을 변화하면 값이 맞지않게 나옴.
순차적으로 접근해야 제대로 나옴.

동기화 블록 
범위내에 블록만 동기화시키겠다.

//Runnable 은 본래 데이터를 공유하지 않는다. 별도의 객체 각각의 일을 하기 때문에 
그런데 해주기 위해 return요구를 충족시켜주기 위해 Callable만듦. 

스레드의 종료를 기다리다가 쓰레드의 결과값을 별도의 메소드를 호출하지않고 값을 받음.
ex) Future <Integer> fur = exr.submit(task);
	Integer r = fur. get(스레드의 값을 가져옴.);
	
Callable에 대해 return 받는 것을 Future로 받는다.

<return받을 값의 형태>제네릭을 이용.

criticObj .lock() - unlock() : 범위를 지정하는 것과 같음.
예외로 빠져서 락이 안풀리면 피시 재부팅해야함. 그래서 사용
new생성자로 생성해줘야함.

서로의 변수간에는 접근 안됨.

